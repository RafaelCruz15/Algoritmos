import numpy as np
import matplotlib.pyplot as plt

# Lecture 3 - Introduction to NumPy

#-----------------------Arreglos basicos en Numpay-----------------------
print("                 Arreglos basicos en Numpay")
stock_list = [3.5, 5, 2, 8, 4.2]
# crea la matriz
returns = np.array(stock_list)
print (returns, type(returns))

# matriz de 2x2
A = np.array([[1, 2], [3, 4]])
print (A, type(A))

# accede al tamaño de la matriz nxm
print (A.shape)

# retorna el indice 0 y len - 1
print (returns[0], returns[len(returns) - 1])

# toma desde la posicion 1 hasta la 3
print (returns[1:3])

#accedemos a la primera columna de la matriz
print (A[:, 0])

#accedemos a la primera fila de la matriz
print (A[0, :])

# elemento de tipo matriz
print (type(A[0,:]))

# podemos acceder mirando solo un indice de la matriz
print (A[0])    #fila

# accdemos a un indice en especifico
print (A[1, 1])
print()

#-----------------------Funciones Array-----------------------
print("                 Funciones Array")
# logaritmo de cada elemento
print (np.log(returns))

# calcula la media
print (np.mean(returns))

# calcula el maximo
print (np.max(returns))
print()

#-----------------------Volver a las devoluciones-----------------------
print("                 Volver a las devoluciones")
# multiplica la matriz*2 y le suma 5
print(returns*2 + 5)

# calcula a muedia y la desviacion estandar
print ("Mean: ", np.mean(returns), "Std Dev: ", np.std(returns))

# creamos una matriz de 10 x 100 (ej. cartera)  2 dimensiones
N = 10
assets = np.zeros((N, 100))
returns = np.zeros((N, 100))

# valor inicial - vectores R_1 de 1 dimension
R_1 = np.random.normal(1.01, 0.03, 100) # 100 muestras aleatorias
returns[0] = R_1
assets[0] = np.cumprod(R_1)

# Usaremos este activo base para crear algunos otros activos aleatorios
# que estén correlacionados con él.

# Generar activos que están correlacionados con R_1
for i in range(1, N):
    R_i = R_1 + np.random.normal(0.001, 0.02, 100)
    returns[i] = R_i  # Establece cada fila de devoluciones igual a la nueva matriz R_i
    assets[i] = np.cumprod(R_i)

mean_returns = [(np.mean(R) - 1) * 100 for R in returns]
return_volatilities = [np.std(R) for R in returns]

# grafica del activo
plt.bar(np.arange(len(mean_returns)), mean_returns)
plt.xlabel('Stock')
plt.ylabel('Returns')
plt.title('Returns for {0} Random Assets'.format(N));
print()

#-----------------------Calculo del retorno esperado-----------------------
print("                 Calculo del retorno esperado")
# generamos N pesos aleatorios para cada activo de nuestra cartera.
# Tenemos que volver a escalar los pesos para que todos sumen hasta 1.
# Hacemos esto escalando el vector de ponderaciones por la suma total
# de todos los pesos. Este paso asegura que utilizaremos el 100% del
# efectivo de la cartera.
weights = np.random.uniform(0, 1, N)
weights = weights/np.sum(weights)

# calcula el producto escalar entre dos arreglos (producto punto)
# suma de todos los rendimientos de activos escalados por sus respectivos pesos
p_returns = np.dot(weights, mean_returns)
print ("Retorno esperado de la cartera: ", p_returns)
print()

#-----------------------Cuidado con los valores de NaN-----------------------
print("                 Cuidado con los valores de NaN")
#nan : datos que faltan o no existen
v = np.array([1, 2, np.nan, 4, 5])
print (v)

# al calcular la media nos aparecerá nan
print (np.mean(v))

# verificar valores nan con la función isnan ().
print(np.isnan(v))

ix = ~np.isnan(v)   # el ~ indica un no lógico, invirtiendo los booleanos
print (v[ix])       # También podemos simplemente escribir v = v [~ np.isnan (v)]

# calculando la media, vemos que no aparece nan
print (np.mean(v[ix]))
print()

#------------------------------Algebra Lineal----------------------------
print("                        Algebra Lineal")
# matriz de 3x5
A = np.array([
        [1, 2, 3, 12, 6],
        [4, 5, 6, 15, 20],
        [7, 8, 9, 10, 10]
    ])
# matriz de 4x3
B = np.array([
        [4, 4, 2],
        [2, 3, 1],
        [6, 5, 8],
        [9, 9, 9]
    ])

# al multiplicar AXB nos aparecerá error, pues sus matrices
#deben ser cuadradas
#print (np.dot(A, B))

# al multiplicar BXA, cumple la propiedad de tener numero de filas igual
# que el numero de columnas
print (np.dot(B, A))

# calcula la matriz de covarianza
cov_mat = np.cov(returns)
print (cov_mat)

# transpuesta de la matriz: cambiar filas por columnas, y viceversa
print (A)                   # matriz a utilizar
print (np.transpose(A))     # transpuesta

# Cálculo de la volatilidad de la cartera
var_p = np.dot(np.dot(weights, cov_mat), weights.T)
vol_p = np.sqrt(var_p)
print ("Volatilidad de la cartera: ", vol_p)

# Cálculo de confirmación
# ddof: número de grados de libertad a tener en cuenta
vol_p_alt = np.sqrt(np.var(np.dot(weights, returns), ddof=1))
print ("Volatilidad de la cartera: ", vol_p_alt)